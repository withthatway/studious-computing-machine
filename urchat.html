<html>
<title>urChat AI: Your Ultimate Roleplay and AI Text Companion</title>
  [favicon("https://user-uploads.perchance.org/file/1165ccaf94408593d08c052610e14234.png")]
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/showdown/dist/showdown.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
  <style>
    /* Styling for the chat interface */
    body {
      margin: 0;
      font-family: "DM Sans", sans-serif;
      font-size: 90%;
      background-color: #f5f5f5;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      overflow: hidden;
      color: #333;
    }
    a {
      text-decoration: none;
      font-weight: bold;
      background: linear-gradient(90deg, #1e3a8a, #2563eb, #60a5fa);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      transition: color 0.3s ease;
    }
    a:hover {
      color: #3b82f6;
      -webkit-text-fill-color: #3b82f6;
    }
    .urChatContainer {
      width: 95%;
      max-width: 600px;
      overflow-y: auto;
    }
    .urChatMenu-icon {
      position: absolute;
      top: 20px;
      left: 20px;
      background-color: #999;
      padding: 8px;
      border-radius: 2px;
      cursor: pointer;
      z-index: 1000;
    }
    .urChatMenu-icon i {
      color: #fff;
      font-size: 24px;
    }
    /* Styling for the menu */
    .urChatMenu {
      position: absolute;
      top: 0;
      left: -300px;
      width: 300px;
      height: 100%;
      background-color: #ddd;
      padding: 20px;
      box-shadow: 2px 0 5px rgba(0, 0, 0, 0.5);
      transition: left 0.3s ease;
      z-index: 1000;
      overflow-y: auto;
    }
    .urChatMenu.open {
      left: 0;
    }
    .urChatMenu h2 {
      color: #fff;
      text-align: left;
      margin-top: 0;
      margin-bottom: 0;
      border-radius: 3px;
      background-color: #192a3c;
      padding-top: 5px;
      padding-bottom: 5px;
      padding-left: 10px;
      padding-right: 10px;
    }
    .urChatMenu label {
      color: #333;
      display: block;
      margin-top: 10px;
    }
    .urChatMenu input,
    .urChatMenu textarea,
    .urChatMenu select {
      width: 100%;
      padding: 5px;
      margin-top: 5px;
      border-radius: 5px;
      border: 1px solid #ccc;
      background-color: #fafafa;
    }
    .urChatMenu button {
      margin-top: 10px;
      padding: 10px;
      width: 100%;
      border: none;
      border-radius: 5px;
      background-color: #999;
      color: white;
      cursor: pointer;
    }
    .urChatMenu .urChatProfile-list {
      margin-top: 20px;
    }
    .urChatMenu .urChatProfile-list h3 {
      color: #333;
    }
    .urChatMenu .urChatProfile-list ul {
      list-style: none;
      padding: 0;
      max-height: 550px;
      overflow-y: auto;
    }
    .urChatMenu .urChatProfile-list ul li {
      color: #333;
      padding: 5px 0;
      display: flex;
      align-items: center;
      cursor: pointer;
    }
    .urChatMenu .urChatProfile-list ul li img {
      width: 50px;
      height: 50px;
      object-fit: cover;
      border-radius: 2px;
      margin-right: 10px;
    }
    .urChatMenu .urChatProfile-list ul li .urChatBtn-group {
      margin-left: auto;
      display: flex;
    }
    .urChatMenu .urChatProfile-list ul li .urChatBtn-group button {
      background: none;
      border: none;
      color: #333;
      cursor: pointer;
      margin-left: 5px;
    }
    .urChatMenu .urChatClose-button {
      position: absolute;
      top: 20px;
      right: 20px;
      background-color: #555;
      padding: 8px;
      border-radius: 2px;
      cursor: pointer;
    }
    .urChatMenu .urChatClose-button i {
      color: white;
      font-size: 18px;
    }
    .urChatMenu-icon,
    .urChatThreads-icon {
      position: absolute;
      top: 20px;
      background-color: #999;
      padding: 8px;
      border-radius: 2px;
      cursor: pointer;
      z-index: 1000;
    }
    .urChatMenu-icon {
      left: 20px;
    }
    .urChatThreads-icon {
      right: 20px;
    }
    .urChatMenu-icon i,
    .urChatThreads-icon i {
      color: #fff;
      font-size: 24px;
    }
    .urChatMessage {
      display: flex;
      align-items: flex-start;
      margin-bottom: 20px;
    }
    .urChatMessage img {
      width: 50px;
      height: auto;
      object-fit: cover;
      border-radius: 2px;
      margin-right: 10px;
      background-color: #ccc;
    }
    .urChatMessageContent {
      background-color: #e0e0e0;
      padding: 10px;
      border-radius: 5px;
      position: relative;
      flex-grow: 1;
      text-align: left;
    }
    .urChatMessageContent textarea {
      width: 100%;
      margin-bottom: 20px;
      resize: vertical;
    }
    .urChatMessageContent.user {
      background-color: #e0e0e0;
    }
    .urChatMessageContent.assistant {
      background-color: #e3e3e3;
    }
    .urChatMessageContent.system {
      background-color: #dedede;
    }
    .urChatMessageContent .urChatHeader {
      font-weight: bold;
      margin-bottom: 5px;
    }
    .urChatMessageContent .urChatText {
      margin-bottom: 30px;
    }
    .urChatMessageContent .urChatIcon {
      position: absolute;
      bottom: 10px;
      right: 10px;
      cursor: pointer;
    }
    .urChatMessageContent .urChatIcon.edit {
      right: 40px;
    }
    .urChatMessageContent .urChatIcon.regenerate {
      right: 70px;
    }
    .urChatMessageContent .urChatIcon.okay {
      right: 10px;
      display: inline-block;
    }
    .urChatMessageContent .delete-btn {
      position: absolute;
      bottom: 5px;
      left: 10px;
      cursor: pointer;
      padding: 5px;
      background-color: transparent;
      color: dark;
      border: none;
    }
    .urChatInput-container {
      position: relative;
      width: 95%;
      max-width: 600px;
      margin: 0 auto 10px;
      transition: transform 0.3s ease, width 0.3s ease, height 0.3s ease;
      transform: translateY(0); /* Default posisi */
    }
    .urChatInput-container.fullscreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1000;
      transform: translateY(-100%); /* Animasi ke atas */
      animation: slideIn 0.3s forwards;
    }
    .urChatInput-container.exit-fullscreen {
      transform: translateY(100%); /* Animasi ke bawah */
      animation: slideOut 0.3s forwards;
    }
    @keyframes slideIn {
      from {
        transform: translateY(100%);
      }
      to {
        transform: translateY(0);
      }
    }
    @keyframes slideOut {
      from {
        transform: translateY(0);
      }
      to {
        transform: translateY(100%);
      }
    }
    .urChatInput-container textarea {
      width: 100%;
      min-height: 100px;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 10px;
      background-color: #fafafa;
      font-family: "DM Sans", sans-serif;
      margin: 0;
      position: relative;
      z-index: 1;
      resize: vertical;
      transition: height 0.3s ease;
    }
    .urChatButton-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    .urChatButton-container button {
      position: absolute;
      padding: 5px 15px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-family: "DM Sans", sans-serif;
      color: #333;
      background-color: transparent;
      pointer-events: auto;
      z-index: 2;
    }
    .urChatButton-container button i {
      font-size: 18px;
      margin-bottom: 5px;
    }
    .urChatSend-button {
      bottom: 3px;
      right: 5px;
      border: 1px solid #333;
      padding: 5px;
      border-radius: 5px;
      font-size: 12px;
    }
    .urChatPersonate-button {
      bottom: 3px;
      left: 7px;
      border: 1px solid #333;
      padding: 5px;
      border-radius: 5px;
      font-size: 12px;
    }
    .urChatImageBtn {
      bottom: 3px;
      left: 50px;
      border: 1px solid #333;
      padding: 5px;
      border-radius: 5px;
      font-size: 12px;
    }
    .urChatFullTextarea-Button {
      top: 10px;
      right: 5px;
      color: #333;
      background-color: transparent;
      border: 1px solid #333;
      padding: 5px;
      border-radius: 5px;
      font-size: 12px;
    }
    .urChatToken-use {
      font-size: 12px;
      color: #999;
      margin-top: 5px;
    }
    .urMsgCopyPopup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 10px 15px;
      background-color: rgba(0, 0, 0, 0.75);
      color: white;
      border-radius: 5px;
      z-index: 1000;
      text-align: center;
      opacity: 0.9;
    }
    .urChatEdit-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      border-radius: 5px;
      max-width: 500px;
      width: 100%;
      box-sizing: border-box;
      overflow-y: auto;
      max-height: 80vh;
    }

    .urChatEdit-popup h3 {
      margin-top: 0;
    }

    .urChatEdit-popup textarea {
      width: 100%;
      height: 100px;
      resize: vertical;
      margin-bottom: 10px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
      border-radius: 5px;
    }

    .urChatEdit-popup button {
      padding: 10px 20px;
      margin-right: 10px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    .urChatEdit-popup button#editMessageProceedBtn {
      background: #28a745;
      color: white;
    }

    .urChatEdit-popup button#editMessageCancelBtn {
      background: #dc3545;
      color: white;
    }
    .urChatEdit-popup label {
      display: block;
      margin-top: 10px;
    }
    .urChatEdit-popup input,
    .urChatEdit-popup textarea {
      width: 100%;
      padding: 5px;
      margin-top: 5px;
      border: 1px solid #ccc;
      border-radius: 5px;
      background-color: #fafafa;
    }
    .urChatEdit-popup button {
      margin-top: 10px;
      padding: 5px 10px;
      background-color: #999;
      border: none;
      color: white;
      border-radius: 5px;
    }
    .urChatTypography {
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 10px 0;
    }
    .urChatTypestyle {
      display: inline-block;
      width: 10px;
      height: 10px;
      background-color: #999;
      border-radius: 50%;
      margin: 0 3px;
      margin-bottom: 10px;
      animation: bounce 1.6s infinite;
    }
    .urChatTypestyle:nth-child(2) {
      animation-delay: 0.2s;
    }
    .urChatTypestyle:nth-child(3) {
      animation-delay: 0.4s;
    }
    @keyframes bounce {
      0%,
      20%,
      50%,
      80%,
      100% {
        transform: translateY(0);
      }
      40% {
        transform: translateY(-10px);
      }
      60% {
        transform: translateY(-5px);
      }
    }
    /* Hide input elements and show prompt on homepage */
    .urChatHomepage-prompt {
      font-size: 18px;
      color: #333;
      text-align: center;
      margin: 20px;
    }
    .urChatInput-container,
    .urChatButton-container,
    .urChatToken-use {
      display: none;
    }
    @keyframes rotateIcon {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }
    .urChatIcon.rotating i {
      animation: rotateIcon 1s linear infinite;
    }
    /* New styles for pop-up commands */
    .urChatPopup {
      position: fixed;
      background-color: #fff;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
      padding: 15px;
      width: 80%;
      max-width: 400px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 2000;
      display: none;
    }
    .urChatPopup .urChatOption {
      border-bottom: 1px solid #ddd;
      padding: 10px;
      cursor: pointer;
    }
    .urChatPopup .urChatOption:last-child {
      border-bottom: none;
    }
    ol,
    ul {
      margin: 0;
      padding-left: 20px;
      list-style-type: decimal;
    }
    li {
      margin: 5px 0;
      font-size: 14px;
    }
    .nested-list {
      margin-left: 20px;
      list-style-type: lower-alpha;
    }
    p {
      margin: 10px 0;
      line-height: 1.5;
    }
    /* Code Container */
    .code-container {
      max-width: 50vw;
      overflow: hidden;
    }
    /* Header Code Block */
    .code-header {
      display: flex;
      justify-content: space-between;
      font-family: Arial, sans-serif;
      background-color: #555;
      padding: 5px;
      border-top-left-radius: 5px;
      border-top-right-radius: 5px;
    }
    .code-header .language-name {
      font-weight: bold;
      align-content: center;
      font-size: 12px;
      color: white;
    }
    .code-header button {
      background-color: #444;
      color: white;
      border: none;
      padding: 4px 8px;
      font-size: 0.7rem;
      border-radius: 3px;
      cursor: pointer;
    }
    .code-header button:hover {
      background-color: #555;
    }
    /* Code Block Styling */
    pre {
      background-color: #f3f3f3;
      border-bottom-right-radius: 5px;
      border-bottom-left-radius: 5px;
      white-space: pre-wrap;
      word-wrap: break-word;
      max-height: 600px;
      overflow-x: auto;
      overflow-y: auto;
      margin: 0;
      font-size: 0.65rem;
      line-height: 1.2;
      font-family: "Courier New", Courier, monospace !important;
      width: 100%;
      max-width: 100%;
      padding: 10px;
    }
    /* Inline Code */
    code {
      font-size: 0.85em;
      line-height: 1.2;
      white-space: inherit;
      color: #ffffff;
      background-color: #555;
      padding: 1px 2px;
      border-radius: 2px;
    }
    /* Fullscreen Overlay */
    .fullscreen-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      padding: 10px;
      box-sizing: border-box;
    }
    .fullscreen-editor {
      background-color: #282c34;
      padding: 15px;
      border-radius: 5px;
      width: 90%;
      height: 90%;
      display: flex;
      flex-direction: column;
    }
    .fullscreen-editor textarea {
      flex: 1;
      background: #1e1e1e;
      color: white;
      border: none;
      padding: 10px;
      font-size: 0.8rem;
      font-family: "Courier New", Courier, monospace;
      resize: none;
      border-radius: 3px;
    }
    .editor-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }
    .editor-buttons button {
      background-color: #444;
      color: white;
      border: none;
      padding: 5px 10px;
      font-size: 0.75rem;
      cursor: pointer;
      border-radius: 3px;
    }
    .editor-buttons button:hover {
      background-color: #555;
    }
    /* Responsiveness */
    @media (max-width: 768px) {
      .code-container {
        max-width: 74.6vw;
      }
      pre {
        font-size: 0.85rem;
        line-height: 1.1;
        padding: 2px;
        width: 100%;
        max-width: 74.6vw;
        overflow-x: auto;
      }
      .code-header button {
        font-size: 0.65rem;
        padding: 3px 6px;
      }
      .fullscreen-editor {
        padding: 10px;
        width: 100%;
        height: 100%;
      }
      .fullscreen-editor textarea {
        font-size: 0.7rem;
      }
      .editor-buttons button {
        font-size: 0.7rem;
        padding: 4px 8px;
      }
    }
    .urChat-tabs {
      font-size: 1rem;
      display: flex;
      position: center;
      margin: 0 auto;
      flex-direction: column;
      width: auto;
      max-width: 100%;
      overflow-x: auto;
    }
    .urChat-tab-header {
      display: flex;
    }
    .urChat-tab-header div {
      padding: 10px 20px;
      cursor: pointer;
      background-color: #ffffff;
      font-weight: bold;
      flex: 1;
      text-align: center;
      transition: background-color 0.3s ease;
      border-top-left-radius: 4px;
      border-top-right-radius: 4px;
    }
    .urChat-tab-header .active {
      background-color: #e0e0e0;
    }
    .urChat-tab-content {
      padding: 0 20px;
      background-color: #e0e0e0;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      border-bottom-left-radius: 4px;
      border-bottom-right-radius: 4px;
      display: none;
      overflow: hidden;
      transition: max-height 0.3s ease, padding 0.3s ease;
    }
    .urChat-tab-content .content {
      padding: 20px 0;
    }
    .urProfileInputArea {
      width: 80%;
      height: 100px;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      font-family: Arial, sans-serif;
      font-size: 12px;
      word-wrap: break-word;
      box-sizing: border-box;
      display: inline-block;
      vertical-align: top;
    }
    .urProfileSendButton {
      padding: 10px 15px;
      margin-left: 10px;
      background-color: #4caf50;
      border: none;
      border-radius: 5px;
      color: white;
      font-size: 14px;
      cursor: pointer;
      display: inline-block;
      vertical-align: top;
    }
    /* Styles for the scroll to bottom button */
    .scroll-to-bottom-btn {
      position: absolute;
      background-color: rgba(51, 51, 51, 0.8);
      color: white;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      right: 30px;
    }
    .scroll-to-bottom-btn.hidden {
      display: none;
    }
    .action-buttons {
      margin: 10px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
    .action-buttons button {
      background-color: #6197c9;
      color: white;
      font-size: 12px;
      border: none;
      border-radius: 5px;
      padding: 10px 15px;
      margin: 5px;
      cursor: pointer;
      width: calc(50% - 10px);
      transition: background-color 0.3s;
    }
    .action-buttons button:hover {
      background-color: #4d7091;
    }
    .action-buttons input[type="file"] {
      display: none;
    }
    .urChatThreads {
      position: fixed;
      top: 0;
      right: -300px; /* Start off-screen */
      width: 300px;
      height: 100%;
      background-color: #fff;
      box-shadow: -2px 0 5px rgba(0, 0, 0, 0.1);
      transition: right 0.3s ease;
      z-index: 1001;
    }
    .urChatThreads.open {
      right: 0;
    }
    .urChatThreads h2 {
      color: #fff;
      text-align: left;
      margin-top: 20px;
      margin-bottom: 10px;
      background-color: #192a3c;
      padding-top: 5px;
      padding-bottom: 5px;
      padding-left: 10px;
      padding-right: 10px;
    }
    .urChatThreads-list ul {
      list-style: none;
      padding: 0;
      max-height: 550px;
      overflow-y: auto;
    }
    .urChatThreads-list ul li {
      color: #333;
      font-size: 14px;
      padding: 5px 0;
      display: flex;
      align-items: center;
      cursor: pointer;
    }
    .urChatThreads-list ul li img {
      width: 30px;
      height: 30px;
      object-fit: cover;
      border-radius: 2px;
      margin-right: 10px;
      margin-left: 10px;
    }
    .urChatThreads-list ul li .urChatBtn-group {
      margin-left: auto;
      display: flex;
    }
    .urChatThreads-list ul li .urChatBtn-group button {
      background: none;
      border: none;
      color: #333;
      cursor: pointer;
      margin-left: 5px;
    }
    .urChatThreadsClose-button {
      position: absolute;
      top: 20px;
      right: 20px;
      background-color: #555;
      padding: 8px;
      border-radius: 2px;
      cursor: pointer;
    }
    .urChatThreadsClose-button i {
      color: white;
      font-size: 18px;
    }
  </style>
  <script>
    let progress = 0;
    let ellipsisCount = 0;

    const urChatprogressBar = document.getElementById("urChatprogressBarEl");
    const urChatloadingText = document.getElementById("urChatloadingTextEl");
    const urChatloadingScreen = document.getElementById("urChatloadingScreenEl");

    document.addEventListener("DOMContentLoaded", () => {
      const loadingInterval = setInterval(() => {
        progress += 8.5;
        if (progress >= 100) {
          clearInterval(loadingInterval);
          urChatprogressBar.style.width = "100%";
          urChatloadingText.textContent = "Loading complete";
        } else {
          urChatprogressBar.style.width = progress + "%";
          ellipsisCount = (ellipsisCount + 1) % 4;
          urChatloadingText.textContent = "Loading" + ".".repeat(ellipsisCount);
        }
      }, 300);

      window.addEventListener("load", () => {
        setTimeout(() => {
          urChatloadingScreen.style.display = "none";
        }, 3500);
      });
    });

    let currentProfile = null;
    const API_URL = "https://text.pollinations.ai/openai";

    function countTokens(text) {
      return text.split(/\s+/).length;
    }

    function trimMessagesToFit(messages, maxTokens) {
      let totalTokens = 0;
      const trimmedMessages = [];

      for (let i = messages.length - 1; i >= 0; i--) {
        const messageTokens = countTokens(messages[i].content);
        if (totalTokens + messageTokens > maxTokens) break;
        totalTokens += messageTokens;
        trimmedMessages.unshift(messages[i]);
      }
      return trimmedMessages;
    }

    function displayTypingAnimation(textElement, content, progressBar, formatMessage) {
      let index = 0;
      const typingInterval = setInterval(() => {
        if (index < content.length) {
          textElement.innerHTML = window.formatMessage(content.slice(0, index + 1));
          index++;

          if (content[index] === " " || index === content.length) {
            const chatContainer = document.querySelector(".urChatContainer");
            chatContainer.scrollTop = chatContainer.scrollHeight;
          }

          progressBar.style.width = `${(index / content.length) * 100}%`;
        } else {
          clearInterval(typingInterval);
          progressBar.parentElement.hidden = true;
        }
      }, 10);
    }

    function logError(error, context) {
      console.error("Error occurred:", {
        error: error.message || error,
        context,
      });
    }

    function generateSeed(content) {
      let hash = 0;
      for (let i = 0; i < content.length; i++) {
        hash = (hash << 5) - hash + content.charCodeAt(i);
        hash |= 0;
      }
      return Math.abs(hash);
    }

    function updateProgress(percent, progressBarEl) {
      if (progressBarEl) {
        progressBarEl.style.width = `${percent}%`;
      }
    }

    function resetProgress(progressBarEl) {
      updateProgress(0, progressBarEl);
    }

    function createProgressBar(container) {
      let progressBarCtn = container.querySelector(".progressContainer");
      if (!progressBarCtn) {
        progressBarCtn = document.createElement("div");
        progressBarCtn.className = "progressContainer";
        progressBarCtn.style.width = "100%";
        progressBarCtn.style.height = "5px";
        progressBarCtn.style.backgroundColor = "#f0f0f0";
        progressBarCtn.style.borderRadius = "5px";
        progressBarCtn.style.overflow = "hidden";
        progressBarCtn.style.marginTop = "5px";
        progressBarCtn.style.marginBottom = "30px";
        container.appendChild(progressBarCtn);

        const progressBar = document.createElement("div");
        progressBar.className = "progressBar";
        progressBar.style.width = "0%";
        progressBar.style.height = "100%";
        progressBar.style.backgroundColor = "#333";
        progressBar.style.transition = "width 0.3s ease";
        progressBarCtn.appendChild(progressBar);
      } else {
        progressBarCtn.hidden = false;
      }
      return progressBarCtn;
    }

    function simulateProgress(progressBarEl, callback) {
      let percent = 0;
      const interval = setInterval(() => {
        if (percent >= 100) {
          clearInterval(interval);
          callback();
        } else {
          percent += 10;
          progressBarEl.style.width = `${percent}%`;
        }
      }, 500);
    }

    function saveEssence(profileId, intent, userMessage, assistantResponse) {
      const essenceKey = `${profileId}_essence`;
      const essenceData = JSON.parse(localStorage.getItem(essenceKey) || "[]");
      if (!essenceData.find((e) => e.intent === intent && e.user === userMessage)) {
        essenceData.push({ intent, user: userMessage, assistant: assistantResponse });
        localStorage.setItem(essenceKey, JSON.stringify(essenceData));
      }
    }

    // Function to generate a unique ID for messages
    function generateUniqueId() {
      const timestamp = new Date().getTime();
      const randomString = Math.random().toString(36).substring(2, 15);
      return `${timestamp}_${randomString}`;
    }

    function handlePlaceholders(text) {
      if (!currentProfile) return text;
      const replacements = {
        "{{user}}": currentProfile.userName,
        "{{userDescription}}": currentProfile.userDescription,
        "{{char}}": currentProfile.assistantName,
        "{{charDescription}}": currentProfile.assistantDescription,
        "{{system}}": currentProfile.systemName,
        "{{systemDescription}}": currentProfile.systemDescription,
      };
      return text.replace(/{{(user|userDescription|char|charDescription|system|systemDescription)}}/g, (_, key) => {
        switch (key) {
          case "user":
            return replacements["{{user}}"];
          case "char":
            return replacements["{{char}}"];
          case "system":
            return replacements["{{system}}"];
          default:
            return replacements[`{{${key}}}`] || "";
        }
      });
    }

    function loadDynamicFunctions() {
      const defaultMemory = "Memory not defined. Please edit.";
      const defaultLore = "Lore not defined. Please edit.";
      const defaultSummary = "Summary not defined. Please edit.";
      return {
        memory: localStorage[`${currentProfile?.id}_memory`] || defaultMemory,
        lore: localStorage[`${currentProfile?.id}_lore`] || defaultLore,
        summary: localStorage[`${currentProfile?.id}_summary`] || defaultSummary,
      };
    }

    function saveDynamicFunctions(profileId, memory, lore, summary) {
      localStorage[`${profileId}_memory`] = memory;
      localStorage[`${profileId}_lore`] = lore;
      localStorage[`${profileId}_summary`] = summary;
    }

    function createEditPopup(type) {
      const data = loadDynamicFunctions();
      const popup = document.createElement("div");
      popup.className = "urChatPopup";
      const textareaContent = data[type];
      popup.innerHTML = `
          <label for="${type}Textarea">${type.charAt(0).toUpperCase() + type.slice(1)}</label>
          <textarea id="${type}Textarea">${textareaContent}</textarea>
          <button id="saveButtonEl">Save</button>
          <button id="cancelButtonEl">Cancel</button>
        `;
      document.body.appendChild(popup);
      popup.id = `${type}Popup`;
      popup.style.display = "block";
      const saveButtonEl = popup.querySelector("#saveButtonEl");
      const cancelButtonEl = popup.querySelector("#cancelButtonEl");
      saveButtonEl.addEventListener("click", () => updateAndClosePopup(type, popup.id));
      cancelButtonEl.addEventListener("click", () => document.body.removeChild(popup));
    }

    function updateAndClosePopup(type, popupId) {
      const textarea = document.getElementById(`${type}Textarea`);
      const updatedValue = textarea.value.trim();
      if (updatedValue) {
        saveDynamicFunctions(
          currentProfile.id,
          type === "memory" ? updatedValue : localStorage[`${currentProfile.id}_memory`],
          type === "lore" ? updatedValue : localStorage[`${currentProfile.id}_lore`],
          type === "summary" ? updatedValue : localStorage[`${currentProfile.id}_summary`]
        );
      }
      document.body.removeChild(document.getElementById(popupId));
    }

    function queryEntry() {
      if (!currentProfile) return "No query entry without a profile.";
      return `Generating query for: ${currentProfile.userName} interacting with ${currentProfile.assistantName}, considering the current conversation context.`;
    }

    function summary() {
      if (!currentProfile) return "No summary available.";
      const { summary } = loadDynamicFunctions();
      return summary;
    }

    function checkMemory(chatHistory) {
      const { memory } = loadDynamicFunctions();
      console.log("Memory:", memory);
      const MAX_TOKENS = 8192;
      const tokenCount = chatHistory.reduce((acc, msg) => acc + msg.content.length / 4, 0);
      return tokenCount > MAX_TOKENS;
    }

    function loreEntry() {
      const { lore } = loadDynamicFunctions();
      return prompt("Enter Lore or provide URL for loading:", lore);
    }

    function handleSlashCommand(textarea) {
      if (textarea.value.includes("/sys")) {
        showPopup();
        textarea.value = textarea.value.replace("/", "");
      }
    }

    function showPopup() {
      const popup = document.createElement("div");
      popup.className = "urChatPopup";
      popup.innerHTML = `
          <div class="urChatOption" onclick="popupCallback('query')">Query Entry</div>
          <div class="urChatOption" onclick="popupCallback('summary')">Summary</div>
          <div class="urChatOption" onclick="popupCallback('memory')">Memory</div>
          <div class="urChatOption" onclick="popupCallback('lore')">Lore</div>
        `;
      document.body.appendChild(popup);
      popup.style.display = "block";
    }

    function popupCallback(option) {
      const popup = document.querySelector(".urChatPopup");
      if (popup) document.body.removeChild(popup);
      if (option === "memory" || option === "lore" || option === "summary") {
        createEditPopup(option);
        return;
      }
      let result = "";
      switch (option) {
        case "query":
          result = queryEntry();
          break;
        default:
          return;
      }
      const textarea = document.querySelector(".urChatInput-container textarea");
      textarea.value = `${result}\n${textarea.value}`;
    }

    function toggleMenu() {
      document.querySelector(".urChatMenu").classList.toggle("open");
    }

    function saveLastSelectedModel() {
      const modelSelect = document.getElementById("model_list_uniqueEl");
      localStorage.lastSelectedModel = modelSelect.value;
      if (currentProfile) {
        currentProfile.model = modelSelect.value;
        updateProfilesInStorage();
      }
    }

    function updateProfilesInStorage() {
      const profiles = JSON.parse(localStorage.profiles || "[]");
      const profileIndex = profiles.findIndex((profile) => profile.id === currentProfile.id);
      profiles[profileIndex] = currentProfile;
      localStorage.profiles = JSON.stringify(profiles);
    }

    document.addEventListener("DOMContentLoaded", () => {
      const modelSelect = document.getElementById("model_list_uniqueEl");
      const lastSelectedModel = localStorage.lastSelectedModel;
      if (lastSelectedModel) {
        modelSelect.value = lastSelectedModel;
      }
      loadProfiles();

      const textarea = document.querySelector(".urChatInput-container textarea");
      textarea.addEventListener("input", () => {
        handleSlashCommand(textarea);
        updateTokenCount(textarea);
      });

      document.addEventListener("click", (event) => {
        const menu = document.querySelector(".urChatMenu");
        const icon = document.querySelector(".urChatMenu-icon");
        if (!menu.contains(event.target) && !icon.contains(event.target)) {
          menu.classList.remove("open");
        }
      });

      const scrollButton = document.querySelector(".scroll-to-bottom-btn");
      const chatContainer = document.querySelector(".urChatContainer");

      chatContainer.addEventListener("scroll", () => {
        if (chatContainer.scrollTop < chatContainer.scrollHeight - chatContainer.clientHeight - 100) {
          scrollButton.classList.remove("hidden");
        } else {
          scrollButton.classList.add("hidden");
        }
      });

      document.querySelector(".urChatSend-button").addEventListener("click", sendUserMessage);
    });

    function updateTokenCount(textarea) {
      const text = textarea.value;
      const tokenCount = Math.ceil(text.length / 4);
      const maxTokens = 3000;
      document.querySelector(".urChatToken-use").textContent = `Token use (${tokenCount}/${maxTokens})`;
    }

    let chatContainer;

    document.addEventListener("DOMContentLoaded", () => {
      chatContainer = document.querySelector(".urChatContainer");
    });

    let progressInterval;
    let startTime;

    // Ensure currentProfile and currentThread are defined globally
    let currentThread = null;

    // Function to send user message
    async function sendUserMessage() {
      const textarea = document.querySelector(".urChatInput-container textarea");
      const content = textarea.value;

      if (!content.trim()) return;

      if (!currentProfile || !currentThread) {
        alert("Please select a profile and a thread first.");
        return;
      }

      console.log("Sending message:", content);
      console.log("Current Profile ID:", currentProfile.id);
      console.log("Current Thread ID:", currentThread.id);

      displayMessage(content, "user", false, generateUniqueId());
      textarea.value = "";

      getAssistantResponse(content);
    }

    // Function to get assistant response
    async function getAssistantResponse(userContent) {
      if (!currentProfile || !currentThread) {
        alert("Please select a profile and a thread first.");
        return;
      }

      const model = currentProfile.model || document.getElementById("model_list_uniqueEl").value;
      const content = userContent;

      const sendBtn = document.querySelector(".urChatSend-button");
      sendBtn.disabled = true;
      sendBtn.innerHTML = `<i class="fas fa-spinner fa-spin"></i>`;

      createProgressBar(chatContainer);
      resetProgress();

      const chatId = generateUniqueId();
      const chatHistoryKey = `${currentProfile.id}_thread_${currentThread.id}_chatHistory`;
      const chatHistory = JSON.parse(localStorage.getItem(chatHistoryKey)) || [];

      // Add user message to chat history
      chatHistory.push({
        id: chatId,
        role: "user",
        content: content,
      });

      const assistantMessage =
        `Given the current circumstances and discussions, you will embody the character named ${currentProfile.assistantName}, ` +
        `defined as: ${currentProfile.assistantDescription || "No Assistant description available"}. ` +
        `Stay in character at all times, and interact dynamically with ${currentProfile.userName}, described as: ` +
        `${currentProfile.userDescription || "No user description available"}. ` +
        `System Prompt: ${currentProfile.systemDescription || "No system description available"}.`;

      const MAX_CONTEXT_MESSAGES = 10;
      const recentMessages = chatHistory.slice(-MAX_CONTEXT_MESSAGES);
      const messages = [{ role: "system", content: assistantMessage }, ...recentMessages, { role: "user", content: content }];

      try {
        const seed = content !== "" ? 42 : Math.floor(Math.random() * 10000);
        localStorage[`${currentProfile.id}_seed`] = seed;

        startTime = Date.now();
        const assistantResponse = await getAssistantResponseFromMessages(messages, model, seed);

        // Display assistant response
        displayMessage(assistantResponse, "assistant", true);

        // Add assistant response to chat history
        chatHistory.push({
          id: generateUniqueId(),
          role: "assistant",
          content: assistantResponse,
        });
        localStorage.setItem(chatHistoryKey, JSON.stringify(chatHistory));

        // Update thread name if needed
        if (chatHistory.length >= 4) {
          updateThreadNameFromConversation();
        }
      } catch (error) {
        console.error("API Error:", error);

        const errorMessage = "Sorry, there was an error processing your request.";
        displayMessage(errorMessage, "assistant");

        // Add error message to chat history
        chatHistory.push({
          id: generateUniqueId(),
          role: "assistant",
          content: errorMessage,
        });
        localStorage.setItem(chatHistoryKey, JSON.stringify(chatHistory));
      } finally {
        // Re-enable send button
        sendBtn.disabled = false;
        sendBtn.innerHTML = `<i class="fas fa-paper-plane"></i>`;

        // Update progress bar
        clearInterval(progressInterval);
        setTimeout(() => {
          updateProgress(100);
          setTimeout(() => {
            const progressBarCtn = chatContainer.querySelector(".progressContainer");
            if (progressBarCtn) progressBarCtn.hidden = true;
          }, 500);
        }, Math.max(1000 - (Date.now() - startTime), 0));
      }
    }

    async function getAssistantResponseFromMessages(messages, model, seed) {
      try {
        const response = await axios.post(
          API_URL,
          {
            messages: messages,
            model: model,
            seed: seed,
          },
          {
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
        return response.data.choices[0]?.message?.content || response.data.text || "";
      } catch (error) {
        console.error("API Error:", error);
        throw error;
      }
    }

    // Function to regenerate message
    async function regenerateMessage(textEl) {
      if (!currentProfile || !currentThread) {
        alert("Please select a profile and a thread first.");
        return;
      }

      const messageElement = textEl.closest(".urChatMessageContent");
      const regenerateIcon = messageElement.querySelector(".urChatIcon.regenerate");
      regenerateIcon.classList.add("rotating");

      const progressBarCtn = createProgressBar(messageElement);
      const progressBar = progressBarCtn.querySelector(".progressBar");

      resetProgress(progressBar);

      let chatHistory = JSON.parse(localStorage.getItem(`${currentProfile.id}_thread_${currentThread.id}_chatHistory`) || "[]");
      const messageIndex = chatHistory.findIndex((msg) => msg.content === textEl.textContent);

      let previousUserMessage = "No user input provided.";
      let previousAssistantMessage = "No assistant message found.";

      if (messageIndex > 0) {
        previousUserMessage = chatHistory[messageIndex - 1]?.content || previousUserMessage;
      } else if (messageIndex === -1) {
        const lastUserMessageIndex = chatHistory
          .slice()
          .reverse()
          .findIndex((msg) => msg.role === "user");
        if (lastUserMessageIndex >= 0) {
          previousUserMessage = chatHistory[chatHistory.length - 1 - lastUserMessageIndex]?.content || previousUserMessage;
        }
      } else {
        previousAssistantMessage = chatHistory[messageIndex]?.content || previousAssistantMessage;
      }

      const isPreviousMessageError = textEl.textContent.includes("Error: Unable to regenerate message.") || textEl.textContent.includes("Error in fetching regenerated message.");

      const assistantMessage =
        `Given the current circumstances and discussions, you will embody the character named ${currentProfile.assistantName}, ` +
        `defined as: ${currentProfile.assistantDescription || "No Assistant description available"}. ` +
        `Stay in character at all times, and interact dynamically with ${currentProfile.userName}, described as: ` +
        `${currentProfile.userDescription || "No user description available"}. ` +
        `System Prompt: ${currentProfile.systemDescription || "No system description available"}. ` +
        `User's previous message: "${previousUserMessage}". ` +
        `Previous assistant response was an error: "${isPreviousMessageError ? "Yes" : "No"}. ` +
        `If it was an error, please focus on providing a distinct and contextually accurate response.`;

      const model = currentProfile.model || document.getElementById("model_list_uniqueEl").value;
      const seed = Math.floor(Math.random() * 10000);

      const startTime = Date.now();

      try {
        const messages = [
          {
            role: "system",
            content: assistantMessage,
          },
        ];

        const regeneratedText = await getAssistantResponseFromMessages(messages, model, seed);
        textEl.innerHTML = "";
        displayTypingAnimation(textEl, regeneratedText, progressBar);
        setTimeout(() => {
          resetProgress(progressBar);
          textEl.innerHTML = formatMessage(regeneratedText);
        }, regeneratedText.length * 10 + 500);

        if (messageIndex >= 0) {
          chatHistory[messageIndex].content = regeneratedText;
        } else {
          if (chatHistory[chatHistory.length - 1]?.role === "assistant") chatHistory.pop();
          chatHistory.push({
            id: generateUniqueId(),
            role: "assistant",
            content: regeneratedText,
          });
        }

        localStorage.setItem(`${currentProfile.id}_thread_${currentThread.id}_chatHistory`, JSON.stringify(chatHistory));
      } catch (error) {
        console.error("Error during message regeneration:", error);
        textEl.textContent = "Error: Unable to regenerate message.";
      } finally {
        regenerateIcon.classList.remove("rotating");
        resetProgress(progressBar);
      }
    }

    async function personateMe() {
      if (!currentProfile) {
        alert("Please select a profile first.");
        return;
      }

      const inputEl = document.querySelector(".urChatInput-container textarea");
      const isFirstInteraction = !localStorage.getItem(`${currentProfile.id}_chatHistory`);

      let prompt;

      if (isFirstInteraction) {
        prompt =
          `Act as ${currentProfile.userName}, described as: ${currentProfile.userDescription || "No user description available"}. ` +
          `System Prompt: ${currentProfile.systemDescription || "No system description available"}. ` +
          `This is the first interaction. Respond naturally and appropriately to the input: "${inputEl.value}".`;
      } else {
        const chatHistory = JSON.parse(localStorage.getItem(`${currentProfile.id}_chatHistory`) || "[]");
        const lastAssistantMessage = chatHistory.filter((msg) => msg.role === "assistant").slice(-1)[0]?.content || "No previous assistant message.";
        const lastUserMessage = chatHistory.filter((msg) => msg.role === "user").slice(-1)[0]?.content || "No previous user message.";

        prompt =
          `Act as ${currentProfile.userName}, described as: ${currentProfile.userDescription || "No user description available"}. ` +
          `System Prompt: ${currentProfile.systemDescription || "No system description available"}. ` +
          `The following is the conversation context:\n` +
          `Assistant said: "${lastAssistantMessage}"\n` +
          `Your previous response was: "${lastUserMessage}".\n` +
          `Now, respond to this input as yourself (in character as ${currentProfile.userName}): "${inputEl.value}".`;
      }

      const typingDots = document.querySelector(".urChatTyping-indicator");
      typingDots.hidden = false;

      const personateBtn = document.querySelector(".urChatPersonate-button");
      personateBtn.disabled = true;
      personateBtn.innerHTML = `<i class="fas fa-spinner fa-spin"></i>`;

      try {
        const response = await axios.post(
          API_URL,
          {
            messages: [{ role: "user", content: prompt }],
            model: currentProfile.model || document.getElementById("model_list_uniqueEl").value,
          },
          {
            headers: { "Content-Type": "application/json" },
          }
        );

        const userResponse = response.data.choices[0]?.message?.content || response.data.text || "No response generated.";
        inputEl.value = userResponse;
      } catch (error) {
        console.error("Error during personate:", error);
        inputEl.value = "Error: Unable to generate response.";
      } finally {
        personateBtn.disabled = false;
        personateBtn.innerHTML = `<i class="fas fa-magic"></i>`;
        typingDots.hidden = true;
      }
    }

    // Function to display a message in the chat container
    function displayMessage(message, sender, animateTyping = false, messageId) {
      const container = document.querySelector(".urChatContainer");
      if (!container) {
        console.error("Container not found.");
        return;
      }

      console.log("Displaying message:", message);
      console.log("Sender:", sender);
      console.log("Message ID:", messageId);

      // Avoid duplicate messages based on ID
      if (messageId && document.querySelector(`.urChatMessage[data-id="${messageId}"]`)) {
        console.warn(`Message with ID ${messageId} already exists.`);
        return;
      }

      const messageElement = document.createElement("div");
      messageElement.classList.add("urChatMessage");
      const id = messageId || generateUniqueId();
      messageElement.dataset.id = id;

      let photoSrc;
      let senderName;
      if (sender === "user") {
        photoSrc = currentProfile.userPhoto;
        senderName = currentProfile.userName;
      } else if (sender === "assistant") {
        photoSrc = currentProfile.assistantPhoto;
        senderName = currentProfile.assistantName;
      } else if (sender === "system") {
        photoSrc = currentProfile.systemPhoto;
        senderName = currentProfile.systemName;
      } else {
        console.error("Unknown sender role:", sender);
        return;
      }

      const img = document.createElement("img");
      img.src = photoSrc ?? "https://placehold.co/50x50";
      img.alt = `${sender} profile picture`;
      img.width = 50;
      img.height = 50;
      messageElement.appendChild(img);

      const messageContent = document.createElement("div");
      messageContent.classList.add("urChatMessageContent", sender);

      const header = document.createElement("div");
      header.classList.add("urChatHeader");
      header.textContent = senderName;
      messageContent.appendChild(header);

      const text = document.createElement("div");
      text.classList.add("urChatText");
      messageContent.appendChild(text);

      // Ensure message is displayed
      if (animateTyping && sender === "assistant") {
        const progressBarContainer = createProgressBar(messageContent);
        const progressBar = progressBarContainer.querySelector(".progressBar");
        displayTypingAnimation(text, message, progressBar);
      } else {
        text.innerHTML = formatMessage(message);
      }

      const editIcon = document.createElement("div");
      editIcon.classList.add("urChatIcon", "edit");
      editIcon.innerHTML = '<i class="fas fa-pen"></i>';
      editIcon.onclick = () => showEditPopup(messageContent, text, editIcon);
      messageContent.appendChild(editIcon);

      // Add regenerate and copy buttons for assistant messages
      if (sender !== "user") {
        const regenerateIcon = document.createElement("div");
        regenerateIcon.classList.add("urChatIcon", "regenerate");
        regenerateIcon.innerHTML = '<i class="fas fa-sync-alt"></i>';
        regenerateIcon.onclick = () => regenerateMessage(text);
        messageContent.appendChild(regenerateIcon);

        const copyIcon = document.createElement("div");
        copyIcon.classList.add("urChatIcon");
        copyIcon.innerHTML = '<i class="fas fa-copy"></i>';
        copyIcon.onclick = () => copyMessage(text, copyIcon);
        messageContent.appendChild(copyIcon);
      }

      const deleteButton = document.createElement("button");
      deleteButton.classList.add("delete-btn");
      deleteButton.innerHTML = '<i class="fas fa-trash"></i>';
      deleteButton.onclick = () => deleteMessage(messageElement, message);
      messageContent.appendChild(deleteButton);

      messageElement.appendChild(messageContent);
      container.appendChild(messageElement);

      // Save message to localStorage if no ID is provided
      if (!messageId) {
        saveMessageToLocalStorage(id, message, sender);
      }

      container.scrollTop = container.scrollHeight;
    }

    // Function to load stored chat history
    function loadStoredChat(profile, threadId) {
      if (!profile || !threadId) {
        console.error("Profil atau Thread ID tidak ditemukan.");
        return;
      }

      const chatHistoryKey = `${profile.id}_thread_${threadId}_chatHistory`;
      const chatHistory = JSON.parse(localStorage.getItem(chatHistoryKey) || "[]");

      const container = document.querySelector(".urChatContainer");
      if (!container) {
        console.error("Chat container tidak ditemukan.");
        return;
      }

      // Bersihkan elemen dalam container untuk thread baru
      container.innerHTML = "";

      // Filter dan tampilkan pesan hanya untuk thread yang sesuai
      chatHistory.forEach((msg) => {
        displayMessage(msg.content, msg.role, false, msg.id);
      });
    }

    // Function to save message to localStorage
    function saveMessageToLocalStorage(id, content, sender) {
      if (!currentThread || !currentThread.id) {
        console.error("Thread ID not found. Message cannot be saved.");
        return;
      }

      console.log("Saving message to localStorage:");
      console.log("Profile ID:", currentProfile.id);
      console.log("Thread ID:", currentThread.id);
      console.log("Message ID:", id);
      console.log("Content:", content);
      console.log("Sender:", sender);

      const chatHistoryKey = `${currentProfile.id}_thread_${currentThread.id}_chatHistory`;
      const chatHistory = JSON.parse(localStorage.getItem(chatHistoryKey) || "[]");

      const existingMessageIndex = chatHistory.findIndex((msg) => msg.id === id);

      if (existingMessageIndex !== -1) {
        // Update content if ID is found
        chatHistory[existingMessageIndex].content = content;
        chatHistory[existingMessageIndex].timestamp = new Date().toISOString();
      } else {
        // Add new message if ID is not found
        chatHistory.push({
          id,
          content,
          role: sender,
          timestamp: new Date().toISOString(),
        });
      }

      // Save back to localStorage
      localStorage.setItem(chatHistoryKey, JSON.stringify(chatHistory));
    }

    // Function to format message content
    function formatMessage(message) {
      function escapeHTML(text) {
        return text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }

      function processCodeBlock(match, language, code, inlineCode) {
        const finalCode = code || inlineCode || "";
        const detectedLanguage = language && language.trim() !== "" ? language : "plaintext";
        const highlightedCode = hljs.highlightAuto(finalCode.trim(), detectedLanguage !== "plaintext" ? [detectedLanguage] : undefined).value;
        return `
      <div class="code-container">
        <div class="code-header">
          <span class="language-name">${language || "code"}</span>
          <div class="code-actions">
            <button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy fa-lg"></i></button>
            <button class="fullscreen-btn" onclick="openFullscreen(this)"><i class="fas fa-expand fa-lg"></i></button>
          </div>
        </div>
        <pre><code class="hljs ${language || "plaintext"}">${highlightedCode}</code></pre>
      </div>
    `;
      }

      const converter = new showdown.Converter();
      message = handlePlaceholders(message);

      return message
        .split(/(```[\s\S]*?```|<urimage>[\s\S]*?<\/urimage>)/g)
        .map((part) => {
          if (part.startsWith("<urimage>") && part.endsWith("</urimage>")) {
            return part.replace(/<urimage>([\s\S]+?)<\/urimage>/g, (match, content) => {
              const encodedContent = encodeURIComponent(content.trim());
              return `
            <div style="position: relative; width: 100%; aspect-ratio: 1 / 1; background-color: #d3d3d3; border-radius: 3px; overflow: hidden;">
              <div style="position: absolute; top: 10px; left: 10px; font-family: Arial, sans-serif; font-size: 16px; color: #555; display: flex; align-items: center; gap: 5px;">
                <i class="fas fa-spinner fa-spin" style="font-size: 18px;"></i>
                <span>Loading...</span>
              </div>
              <img src="https://image.pollinations.ai/prompt/${encodedContent}" 
                   style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; border-radius: 3px; visibility: hidden;" 
                   onload="this.style.visibility='visible'; this.previousElementSibling.style.display='none';">
            </div>`;
            });
          } else if (part.startsWith("```")) {
            return part.replace(/```([a-zA-Z]*)\n([\s\S]*?)\n```|```([^`]*)```/g, processCodeBlock);
          } else {
            return converter.makeHtml(part);
          }
        })
        .join("");
    }

    function openFullscreen(button) {
      const codeContainer = button.closest(".code-container");
      const codeContent = codeContainer.querySelector("code").textContent;
      const overlay = document.createElement("div");
      overlay.classList.add("fullscreen-overlay");
      overlay.innerHTML = `
    <div class="fullscreen-editor">
      <textarea>${codeContent}</textarea>
      <div class="editor-buttons">
        <button onclick="closeFullscreen(this)"><i class="fas fa-compress fa-lg"></i></button>
        <button onclick="applyChanges(this)"><i class="fas fa-edit fa-lg"></i></button>
      </div>
    </div>
  `;
      document.body.appendChild(overlay);
      overlay.querySelector("textarea").focus();
      overlay.style.overflow = "auto";
    }

    function closeFullscreen(button) {
      button.closest(".fullscreen-overlay").remove();
    }

    function applyChanges(button) {
      const overlay = button.closest(".fullscreen-overlay");
      const newContent = overlay.querySelector("textarea").value;

      const originalCode = document.querySelector(".code-container pre code");
      originalCode.textContent = newContent;
      hljs.highlightElement(originalCode);
      closeFullscreen(button);
    }

    function copyCode(button) {
      const codeContainer = button.closest(".code-container");
      const codeText = codeContainer.querySelector("code").textContent;
      navigator.clipboard
        .writeText(codeText)
        .then(() => {
          button.innerHTML = `<i class="fas fa-check fa-lg" style="color: #63E6BE;"></i>`;
          setTimeout(() => (button.innerHTML = `<i class="fas fa-copy fa-lg"></i>`), 2000);
        })
        .catch((err) => console.error("Copy failed:", err));
    }

    function editMessage(messageContent, text, editIcon) {
      const textarea = document.createElement("textarea");
      const unformattedText = text.innerHTML
        .replace(/<b>(.*?)<\/b>/g, "**$1**")
        .replace(/<em>(.*?)<\/em>/g, "*$1*")
        .replace(/<h1>(.*?)<\/h1>/g, "# $1\n")
        .replace(/<h2>(.*?)<\/h2>/g, "## $1\n")
        .replace(/<h3>(.*?)<\/h3>/g, "### $1\n")
        .replace(/<p[^>]*>(.*?)<\/p>/gs, "$1")
        .replace(/<br\s*\/?>/gi, "\n")
        .replace(/(<br\s*\/?>\s*){2}/gi, "\n\n")
        .replace(/<hr>/g, "---\n")
        .replace(/<span[^>]*>.*?<\/span>/g, "")
        .replace(/<code>(.*?)<\/code>/g, "`$1`")
        .replace(/<div class="code-container">.*?<span class="language-name">(.*?)<\/span>.*?<pre><code.*?>(.*?)<\/code><\/pre>.*?<\/div>/gs, (_, language, code) => `${language}\n\`\`\`\n${code}\n\`\`\``)
        .replace(/&lt;/g, "<")
        .replace(/&gt;/g, ">")
        .replace(/&amp;/g, "&")
        .replace(/&quot;/g, '"')
        .replace(/&apos;/g, "'")
        .replace(/&grave;/g, "`")
        .replace(
          /<div style="position: relative; width: 100%; aspect-ratio: 1 \/ 1; background-color: #d3d3d3; border-radius: 3px; overflow: hidden;">\s*<div style="position: absolute; top: 10px; left: 10px; font-family: Arial, sans-serif; font-size: 16px; color: #555; display: flex; align-items: center; gap: 5px;">\s*<i class="fas fa-spinner fa-spin" style="font-size: 18px;"><\/i>\s*<span>Loading...<\/span>\s*<\/div>\s*<img src="https:\/\/image\.pollinations\.ai\/prompt\/([^?]+)\?[^"]*"[\s\S]*?<\/div>/g,
          (match, encodedContent) => {
            const decodedContent = decodeURIComponent(encodedContent);
            return `<urimage>${decodedContent}</urimage>`;
          }
        );
      textarea.value = unformattedText;
      messageContent.replaceChild(textarea, text);

      const okayIcon = messageContent.querySelector(".urChatIcon.okay");
      okayIcon.hidden = false;

      const otherIcons = messageContent.querySelectorAll(".urChatIcon");
      otherIcons.forEach((icon) => {
        if (icon !== okayIcon && icon !== editIcon) {
          icon.classList.add("hidden");
        }
      });
      editIcon.classList.add("hidden");
    }

    function updateChatHistory(messageId, newContent, role) {
      const chatHistoryKey = `${currentProfile.id}_thread_${currentThread.id}_chatHistory`;
      const chatHistory = JSON.parse(localStorage.getItem(chatHistoryKey) || "[]");

      const messageIndex = chatHistory.findIndex((msg) => msg.id === messageId);
      if (messageIndex !== -1) {
        chatHistory[messageIndex].content = newContent;
        chatHistory[messageIndex].role = role;
        localStorage.setItem(chatHistoryKey, JSON.stringify(chatHistory));
      } else {
        console.error("Message not found in chat history.");
      }
    }
    // Function to process message edits
    function processMessage(messageContent, text, editIcon, proceedBtn) {
      const textarea = messageContent.querySelector("textarea");
      if (textarea) {
        const updatedContent = textarea.value.trim();
        text.innerHTML = formatMessage(updatedContent);
        messageContent.replaceChild(text, textarea);

        const messageId = messageContent.closest(".urChatMessage").dataset.id;
        const role = messageContent.classList.contains("assistant") ? "assistant" : "user";

        // Perbarui penyimpanan data
        updateChatHistory(messageId, updatedContent, role);
      }

      proceedBtn.hidden = true;
      messageContent.querySelectorAll(".urChatIcon").forEach((icon) => icon.classList.remove("hidden"));
    }

    // Function to show edit pop-up
    function showEditPopup(messageContent, text, editIcon) {
      const popup = document.createElement("div");
      popup.className = "urChatEdit-popup";
      popup.innerHTML = `
      <h3>Edit Message</h3>
      <textarea id="editMessageTextarea">${text.textContent}</textarea>
      <button id="editMessageProceedBtn">Proceed</button>
      <button id="editMessageCancelBtn">Cancel</button>`;

      document.body.appendChild(popup);

      const proceedBtn = popup.querySelector("#editMessageProceedBtn");
      const cancelBtn = popup.querySelector("#editMessageCancelBtn");

      proceedBtn.addEventListener("click", () => {
        const newContent = document.getElementById("editMessageTextarea").value.trim();
        if (!newContent) {
          alert("Message cannot be empty.");
          return;
        }

        const messageId = messageContent.closest(".urChatMessage").dataset.id;
        const role = messageContent.classList.contains("assistant") ? "assistant" : "user";

        // Update local storage data
        updateChatHistory(messageId, newContent, role);
        text.innerHTML = formatMessage(newContent);

        // Panggil loadStoredChat untuk merefresh dengan currentProfile dan currentThread.id
        if (currentProfile && currentThread) {
          loadStoredChat(currentProfile, currentThread.id);
        }

        closeEditPopup(popup); // Close popup after changes
      });

      cancelBtn.addEventListener("click", () => {
        closeEditPopup(popup); // Close popup without changes
      });
    }

    function closeEditPopup(popup) {
      document.body.removeChild(popup);
    }

    // Function to delete message
    function deleteMessage(messageElement, messageContent) {
      const confirmation = confirm("Are you sure you want to delete this message?");
      if (confirmation) {
        const messageId = messageElement.dataset.id;
        const chatHistoryKey = `${currentProfile.id}_thread_${currentThread.id}_chatHistory`;
        const chatHistory = JSON.parse(localStorage.getItem(chatHistoryKey) || "[]");

        // Cari pesan berdasarkan ID
        const messageIndex = chatHistory.findIndex((msg) => msg.id === messageId);
        if (messageIndex !== -1) {
          chatHistory.splice(messageIndex, 1); // Hapus pesan dari chat history
          localStorage.setItem(chatHistoryKey, JSON.stringify(chatHistory)); // Perbarui localStorage
        }

        // Hapus elemen dari UI
        const container = document.querySelector(".urChatContainer");
        container.removeChild(messageElement);

        // Hapus tanda "sudah dimuat"
        if (!container.querySelector(".urChatMessage")) {
          delete container.dataset.loaded; // Izinkan pemuatan ulang jika semua pesan dihapus
        }
      }
    }

    function copyMessage(text, icon) {
      navigator.clipboard.writeText(text.textContent);

      // Mengubah ikon menjadi checkbox hijau tua
      icon.innerHTML = '<i class="fas fa-check" style="color: darkgreen;"></i>';

      // Menampilkan pop-up
      const popup = document.createElement("div");
      popup.classList.add("urMsgCopyPopup");
      popup.innerText = "Message copied to clipboard!";

      // Mengatur posisi dan menampilkannya di tengah
      document.body.appendChild(popup);

      // Animasi Fade In
      popup.style.opacity = "0";
      popup.style.transition = "opacity 0.5s ease";
      setTimeout(() => {
        popup.style.opacity = "1";
      }, 0);

      // Menghilangkan pop-up setelah 1.5 detik dengan animasi Fade Out
      setTimeout(() => {
        popup.style.opacity = "0";
        setTimeout(() => {
          document.body.removeChild(popup);
          // Mengembalikan ikon ke ikon copy
          icon.innerHTML = '<i class="fas fa-copy"></i>';
        }, 500); // Tunggu sampai animasi selesai
      }, 1500);
    }

    async function saveCharacter() {
      const assistantName = nameEl.value.trim();
      const tagline = taglineEl.value.trim();
      const model = model_list_uniqueEl.value;
      const userName = user_nameEl.value.trim();
      const assistantPhoto = photoEl.files[0] ? await fileToBase64(photoEl.files[0]) : "https://user-uploads.perchance.org/file/ae5ea7634bccd677a7bfa7d8be554139.jpeg";
      const userPhoto = user_photoEl.files[0] ? await fileToBase64(user_photoEl.files[0]) : "https://user-uploads.perchance.org/file/ae5ea7634bccd677a7bfa7d8be554139.jpeg";
      const systemName = system_nameEl.value.trim();
      const systemDescription = system_descriptionEl.value.trim();
      const systemPhoto = system_photoEl.files[0] ? await fileToBase64(system_photoEl.files[0]) : "https://user-uploads.perchance.org/file/ae5ea7634bccd677a7bfa7d8be554139.jpeg";

      if (!assistantName || !userName || !systemName) {
        alert("Please provide Assistant, User, and System names.");
        return;
      }

      const profiles = JSON.parse(localStorage.profiles || "[]");
      profiles.push({
        id: generateUniqueId(),
        assistantName,
        tagline,
        assistantPhoto,
        userName,
        userPhoto,
        model,
        assistantDescription: descriptionEl.value,
        userDescription: user_descriptionEl.value,
        systemName,
        systemDescription,
        systemPhoto,
        createdDate: new Date().toISOString(),
      });
      localStorage.profiles = JSON.stringify(profiles);

      refreshProfileList(profiles);

      currentProfile = profiles.find((profile) => profile.userName === userName && profile.assistantName === assistantName);

      localStorage[`${currentProfile.id}_chatHistory`] = JSON.stringify([]);

      currentProfile = profiles[profiles.length - 1];
      updateChatWithCurrentProfile();
    }

    function refreshProfileList(profiles) {
      const profileList = document.querySelector(".urChatProfile-list ul");
      profileList.innerHTML = "";

      profiles
        .sort((a, b) => new Date(b.createdDate) - new Date(a.createdDate))
        .forEach((profile) => {
          const listItem = document.createElement("li");
          const assistantImg = document.createElement("img");
          assistantImg.src = profile.assistantPhoto;
          assistantImg.alt = `${profile.assistantName} profile picture`;
          listItem.appendChild(assistantImg);
          const textContent = document.createElement("div");
          textContent.innerHTML = `${profile.assistantName} <br> ${profile.tagline}`;
          listItem.appendChild(textContent);
          listItem.onclick = () => {
            loadChat(profile.id);
            document.querySelector(".urChatMenu").classList.remove("open");
          };

          const btnGroup = document.createElement("div");
          btnGroup.className = "urChatBtn-group";

          // Edit button
          const editBtn = document.createElement("button");
          editBtn.innerHTML = '<i class="fas fa-edit"></i>';
          editBtn.onclick = (e) => {
            e.stopPropagation(); // Prevent parent click
            currentProfile = profile; // Set the selected profile to be edited
            editProfile("complete"); // Pass the "complete" type to open the edit form
          };
          btnGroup.appendChild(editBtn);

          // Delete button
          const deleteBtn = document.createElement("button");
          deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
          deleteBtn.onclick = (e) => {
            e.stopPropagation(); // Prevent parent click
            deleteProfile(profile.id); // Delete the selected profile
          };
          btnGroup.appendChild(deleteBtn);

          listItem.appendChild(btnGroup);
          profileList.appendChild(listItem);
        });
    }

    function updateChatWithCurrentProfile() {
      if (!currentProfile) return;

      const messages = document.querySelectorAll(".urChatMessage");
      messages.forEach((message) => {
        const img = message.querySelector("img");
        if (img) {
          img.src = message.querySelector(".urChatHeader").textContent.includes(currentProfile.userName) ? currentProfile.userPhoto : currentProfile.assistantPhoto;
        }
      });

      document.querySelector(".urChatInput-container").style.display = "flex";
      document.querySelector(".urChatButton-container").style.display = "flex";
      document.querySelector(".urChatToken-use").style.display = "block";

      const actionButtons = document.querySelector(".action-buttons");
      if (actionButtons) actionButtons.hidden = false;

      refreshProfileList(JSON.parse(localStorage.profiles || "[]"));
    }

    function loadProfiles() {
      const profiles = JSON.parse(localStorage.profiles || "[]");
      refreshProfileList(profiles);

      if (profiles.length === 0) {
        const profileList = document.querySelector(".urChatProfile-list ul");
        profileList.innerHTML = "<li>No profiles available. Create a new one!</li>";
      }
    }

    function toggleCharacterCreation() {
      characterCreationCtn.hidden = !characterCreationCtn.hidden;
    }

    let activePopup = null; // Global reference for the active popup

    function editProfile(type) {
      if (!currentProfile) return;

      let content = "";
      if (type === "assistant" || type === "complete") {
        content = `
      <label for="editAssistantName">Assistant Name:</label>
      <input id="editAssistantNameEl" type="text" value="${currentProfile.assistantName}">
      <label for="editAssistantDescription">Assistant Description:</label>
      <textarea id="editAssistantDescriptionEl">${currentProfile.assistantDescription}</textarea>
      <label for="editAssistantPhoto">Assistant Photo:</label>
      <input id="editAssistantPhotoEl" type="file">
      <label for="editTagline">Tagline:</label>
      <input id="editTaglineEl" type="text" value="${currentProfile.tagline}">
      <label for="editModel">Model:</label>
      <select id="editModelEl">
        ${document.getElementById("model_list_uniqueEl").innerHTML}
      </select>`;
      }
      if (type === "user" || type === "complete") {
        content += `
      <h4>User Profile</h4>
      <label for="editUserName">User Name:</label>
      <input id="editUserNameEl" type="text" value="${currentProfile.userName}">
      <label for="editUserDescription">User Description:</label>
      <textarea id="editUserDescriptionEl">${currentProfile.userDescription}</textarea>
      <label for="editUserPhoto">User Photo:</label>
      <input id="editUserPhotoEl" type="file">`;
      }
      if (type === "system" || type === "complete") {
        content += `
      <h4>System Profile</h4>
      <label for="editSystemName">System Name:</label>
      <input id="editSystemNameEl" type="text" value="${currentProfile.systemName}">
      <label for="editSystemDescription">System Description:</label>
      <textarea id="editSystemDescriptionEl">${currentProfile.systemDescription}</textarea>
      <label for="editSystemPhoto">System Photo:</label>
      <input id="editSystemPhotoEl" type="file">`;
      }
      const popup = document.createElement("div");
      popup.classList.add("urChatEdit-popup");
      popup.innerHTML = `
    <h3>Edit Profile</h3>
    ${content}
    <button onclick="urSaveEditedProfile('${type}')">Save</button>
    <button onclick="urCloseEditPopup(this)">Close</button>`;
      document.body.appendChild(popup);

      activePopup = popup; // Save reference to the active popup

      if (type === "assistant" || type === "complete") {
        document.getElementById("editModelEl").value = currentProfile.model;
      }
    }

    async function urSaveEditedProfile(type) {
      const assistantName = type !== "complete" ? currentProfile.assistantName : document.getElementById("editAssistantNameEl").value;
      const assistantDescription = document.getElementById("editAssistantDescriptionEl").value;
      const assistantPhoto = document.getElementById("editAssistantPhotoEl").files[0] ? await fileToBase64(document.getElementById("editAssistantPhotoEl").files[0]) : currentProfile.assistantPhoto;
      const model = document.getElementById("editModelEl").value;
      const tagline = document.getElementById("editTaglineEl").value;
      const userName = type !== "complete" ? currentProfile.userName : document.getElementById("editUserNameEl").value;
      const userDescription = type !== "complete" ? currentProfile.userDescription : document.getElementById("editUserDescriptionEl").value;
      const userPhoto = type !== "complete" ? currentProfile.userPhoto : document.getElementById("editUserPhotoEl").files[0] ? await fileToBase64(document.getElementById("editUserPhotoEl").files[0]) : currentProfile.userPhoto;
      const systemName = document.getElementById("editSystemNameEl").value || currentProfile.systemName;
      const systemDescription = document.getElementById("editSystemDescriptionEl").value;
      const systemPhoto = document.getElementById("editSystemPhotoEl").files[0] ? await fileToBase64(document.getElementById("editSystemPhotoEl").files[0]) : currentProfile.systemPhoto;

      currentProfile = {
        ...currentProfile,
        assistantName,
        assistantDescription,
        assistantPhoto,
        model,
        tagline,
        userName,
        userDescription,
        userPhoto,
        systemName,
        systemDescription,
        systemPhoto,
      };

      updateProfilesInStorage(); // Update profiles in storage
      urCloseEditPopup(activePopup); // Close popup
      alert("Profile updated successfully!");

      updateChatWithCurrentProfile();
    }

    function urCloseEditPopup(buttonOrPopup) {
      const popup = buttonOrPopup instanceof HTMLElement ? buttonOrPopup.parentNode : buttonOrPopup;
      if (popup && popup.parentNode === document.body) {
        document.body.removeChild(popup);
        activePopup = null; // Clear global reference
      } else {
        console.error("Popup is not a valid child of body.");
      }
    }
    function deleteProfile(profileId) {
      const confirmation = confirm("Are you sure you want to delete the profile?");
      if (confirmation) {
        const profiles = JSON.parse(localStorage.profiles || "[]");
        const profileIndex = profiles.findIndex((profile) => profile.id === profileId);
        if (profileIndex !== -1) {
          const removedProfile = profiles.splice(profileIndex, 1)[0];
          localStorage.profiles = JSON.stringify(profiles);
          localStorage.removeItem(`${removedProfile.id}_chatHistory`);

          // Delete all thread chat histories
          if (removedProfile.threads) {
            removedProfile.threads.forEach((thread) => {
              localStorage.removeItem(`${removedProfile.id}_thread_${thread.id}_chatHistory`);
            });
          }

          currentProfile = null;
          const container = document.querySelector(".urChatContainer");
          container.innerHTML = "";
          loadProfiles();
          document.querySelector(".urChatInput-container").style.display = "none";
          document.querySelector(".urChatButton-container").style.display = "none";
          document.querySelector(".urChatToken-use").style.display = "none";
          const actionButtons = document.querySelector(".action-buttons");
          if (actionButtons) actionButtons.hidden = true;
          alert("Profile deleted successfully!");
        }
      }
    }

    async function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result);
        reader.onerror = (error) => reject(error);
      });
    }

    // Clear Chat: Clears all chat for the selected profile
    function clearChat() {
      if (!currentProfile || !currentThread) {
        alert("Please select a profile and a thread first.");
        return;
      }

      if (confirm("Are you sure you want to clear the chat?")) {
        const chatHistoryKey = `${currentProfile.id}_thread_${currentThread.id}_chatHistory`;
        localStorage.setItem(chatHistoryKey, JSON.stringify([]));
        const container = document.querySelector(".urChatContainer");
        container.innerHTML = "";
      }
    }

    // Save Chat: Saves the chat in JSON format
    function saveChat(option) {
      if (!currentProfile || !currentThread) {
        alert("Please select a profile and a thread first.");
        return;
      }

      // Add confirmation alert for saving
      let confirmMessage = "";
      if (option === 1) {
        confirmMessage = "You will save the character only. Do you want to proceed? (y/n)";
      } else if (option === 2) {
        confirmMessage = "You will save all character data including profile and chat. Do you want to proceed? (y/n)";
      }

      if (!confirm(confirmMessage)) {
        return; // Exit if the user chooses not to proceed
      }

      const chatHistoryKey = `${currentProfile.id}_thread_${currentThread.id}_chatHistory`;
      const chatHistory = JSON.parse(localStorage.getItem(chatHistoryKey)) || [];

      let data = {};
      if (option === 1) {
        data = {
          characterDescription: currentProfile.assistantDescription || "No description",
        };
      } else if (option === 2) {
        data = {
          profile: currentProfile,
          thread: currentThread,
          chatHistory: chatHistory,
        };
      }

      const blob = new Blob([JSON.stringify(data, null, 2)], {
        type: "application/json",
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `chat_${currentProfile.id}_thread_${currentThread.id}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }

    // Load Chat: Upload a character in JSON format
    function loadChatJson(fileInput) {
      const file = fileInput.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.readAsText(file);
      reader.onload = () => {
        try {
          const newData = JSON.parse(reader.result);
          if (newData.profile || newData.thread) {
            // Check if there's profile or thread data
            const profiles = JSON.parse(localStorage.profiles || "[]");

            // If it contains profile data, add to profiles and refresh
            if (newData.profile) {
              profiles.push(newData.profile);
            }
            // Update thread data if necessary
            if (newData.thread) {
              const threads = JSON.parse(localStorage.threads || "[]") || [];
              threads.push(newData.thread);
              localStorage.threads = JSON.stringify(threads);
            }

            localStorage.profiles = JSON.stringify(profiles);
            refreshProfileList(profiles); // Assumes you have a function to refresh profiles
            loadChat(newData.profile.id); // The function to load a chat must be defined
          }
        } catch (error) {
          alert("Invalid JSON file.");
        }
      };
      reader.onerror = () => {
        alert("Failed to read file.");
      };
    }

    function toggleTab(tabIndex) {
      var content = document.getElementById("content-" + tabIndex);
      var header = document.getElementById("tab-" + tabIndex + "-header");
      var isActive = content.style.maxHeight && content.style.maxHeight !== "0px";

      if (isActive) {
        content.style.maxHeight = 0;
        content.style.padding = "0 20px";
        header.classList.remove("active");
      } else {
        document.querySelectorAll(".urChat-tab-content").forEach(function (tabContent) {
          tabContent.style.maxHeight = 0;
          tabContent.style.padding = "0 20px";
        });
        document.querySelectorAll(".urChat-tab-header div").forEach(function (tabHeader) {
          tabHeader.classList.remove("active");
        });
        content.style.display = "block";
        content.style.maxHeight = content.scrollHeight + "px";
        content.style.padding = "20px";
        header.classList.add("active");
      }
    }

    async function generateImageDescription() {
      if (!currentThread || !currentThread.id) {
        console.error("Thread ID not found. Message cannot be saved.");
        return;
      }

      const imageBtn = document.querySelector(".urChatImageBtn");
      if (!imageBtn) return;

      imageBtn.disabled = true;
      imageBtn.innerHTML = `<i class="fas fa-spinner fa-spin"></i><br>`;

      try {
        // Ambil riwayat obrolan terbaru
        const chatHistory = JSON.parse(localStorage.getItem(`${currentProfile.id}_thread_${currentThread.id}_chatHistory`) || "[]");
        const context = chatHistory.slice(-2).reduce((acc, msg) => acc + `${msg.role}: ${msg.content}\n`, "");

        // Prompt untuk menghasilkan deskripsi gambar
        const urImagePrompt = `Generate a detailed description of an image based on the provided context.` + `Format your response strictly with the syntax: <urimage>Your detailed description here</urimage>.` + `Context: ${context}`;

        const messages = [
          {
            role: "system",
            content: urImagePrompt,
          },
        ];
        const seed = Math.floor(Math.random() * 10000);

        // Mengirim permintaan POST menggunakan Axios
        const response = await axios.post(
          API_URL,
          {
            model: "mistral-large",
            messages,
            seed,
          },
          {
            headers: {
              "Content-Type": "application/json",
            },
          }
        );

        // Menangani respons dari server
        const assistantResponse = response.data.choices[0]?.message?.content || response.data.text || "No response generated.";

        // Menampilkan dan menyimpan pesan
        displayMessage(assistantResponse, "system");

        // Menghasilkan ID unik untuk pesan baru
        const messageId = generateUniqueId();
      } catch (error) {
        console.error("Error in generating image description:", error);
        alert("Error generating image description.");
      } finally {
        // Reset tombol setelah selesai
        imageBtn.disabled = false;
        imageBtn.innerHTML = `<i class="fas fa-image"></i>`;
      }
    }

    function searchProfiles(searchTerm) {
      const profileItems = document.querySelectorAll(".urChatProfile-list ul li");
      searchTerm = searchTerm.toLowerCase();
      profileItems.forEach((item) => {
        const profileName = item.querySelector("div").textContent.toLowerCase();
        if (profileName.includes(searchTerm)) {
          item.style.display = "flex";
        } else {
          item.style.display = "none";
        }
      });
    }

    function scrollToBottom() {
      document.querySelector(".urChatContainer").scrollTop = document.querySelector(".urChatContainer").scrollHeight;
      document.querySelector(".scroll-to-bottom-btn").classList.add("hidden");
    }

    function toggleFullTextarea() {
      const container = document.querySelector(".urChatInput-container");
      const button = container.querySelector(".urChatFullTextarea-Button");

      if (!container.classList.contains("fullscreen")) {
        container.classList.add("fullscreen");
        container.classList.remove("exit-fullscreen"); // Hilangkan kelas exit jika ada
        button.innerHTML = `<i class="fas fa-compress-alt fa-rotate-270"></i>`;
      } else {
        container.classList.add("exit-fullscreen");
        container.classList.remove("fullscreen");
        button.innerHTML = `<i class="fas fa-expand"></i>`;
      }

      container.addEventListener(
        "animationend",
        () => {
          container.classList.remove("exit-fullscreen");
        },
        { once: true }
      );
    }

    // Function to load chat for a selected profile
    function loadChat(profileId) {
      const confirmLoad = confirm("You are about to load a new profile. Click OK to proceed.");
      if (!confirmLoad) {
        return;
      }

      const container = document.querySelector(".urChatContainer");
      container.innerHTML = "";

      const storedProfiles = JSON.parse(localStorage.profiles || "[]");
      currentProfile = storedProfiles.find((profile) => profile.id === profileId);

      if (!currentProfile) {
        alert("Profile not found. Please create a profile first.");
        return;
      }

      // Set default values if properties are missing
      if (!currentProfile.userPhoto) {
        currentProfile.userPhoto = "https://user-uploads.perchance.org/file/ae5ea7634bccd677a7bfa7d8be554139.jpeg";
      }
      if (!currentProfile.systemPhoto) {
        currentProfile.systemPhoto = "https://user-uploads.perchance.org/file/ae5ea7634bccd677a7bfa7d8be554139.jpeg";
      }
      if (!currentProfile.assistantPhoto) {
        currentProfile.assistantPhoto = "https://user-uploads.perchance.org/file/ae5ea7634bccd677a7bfa7d8be554139.jpeg";
      }

      // Always create a new thread when selecting a profile
      createNewThread();
    }

    function loadThreads() {
      const threadsList = document.querySelector(".urChatThreads-list ul");
      threadsList.innerHTML = "";

      if (currentProfile && currentProfile.threads) {
        currentProfile.threads.forEach((thread) => {
          const listItem = document.createElement("li");
          const assistantImg = document.createElement("img");
          assistantImg.src = currentProfile.assistantPhoto;
          assistantImg.alt = `${currentProfile.assistantName} profile picture`;
          listItem.appendChild(assistantImg);
          const textContent = document.createElement("div");
          textContent.textContent = `${currentProfile.assistantName}: ${thread.name}`;
          listItem.appendChild(textContent);
          const btnGroup = document.createElement("div");
          btnGroup.className = "urChatBtn-group";
          const deleteBtn = document.createElement("button");
          deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
          deleteBtn.onclick = () => deleteThread(currentProfile.id, thread.id);
          btnGroup.appendChild(deleteBtn);
          const renameBtn = document.createElement("button");
          renameBtn.innerHTML = '<i class="fas fa-edit"></i>';
          renameBtn.onclick = () => renameThread(currentProfile.id, thread.id);
          btnGroup.appendChild(renameBtn);
          listItem.appendChild(btnGroup);
          listItem.onclick = () => loadThread(currentProfile.id, thread.id);
          threadsList.appendChild(listItem);
        });
      }
    }

    function loadThread(profileId, threadId) {
      if (currentThread && currentThread.id === threadId) {
        console.log("Thread is already active.");
        return; // Do nothing if the same thread is selected
      }

      const profiles = JSON.parse(localStorage.profiles || "[]");
      currentProfile = profiles.find((profile) => profile.id === profileId);
      if (currentProfile && currentProfile.threads) {
        currentThread = currentProfile.threads.find((thread) => thread.id === threadId);
        if (currentThread) {
          console.log("Loaded thread:", currentThread.name);
          const chatHistoryKey = `${currentProfile.id}_thread_${threadId}_chatHistory`;
          currentThread.chatHistory = JSON.parse(localStorage.getItem(chatHistoryKey)) || [];
          const container = document.querySelector(".urChatContainer");
          container.innerHTML = "";
          currentThread.chatHistory.forEach((msg) => {
            if (msg.role === "system" || msg.role === "assistant" || msg.role === "user") {
              displayMessage(msg.content, msg.role, false, msg.id);
            }
          });
          document.querySelector(".urChatInput-container").style.display = "flex";
          document.querySelector(".urChatButton-container").style.display = "flex";
          document.querySelector(".urChatToken-use").style.display = "block";
          const actionButtons = document.querySelector(".action-buttons");
          if (actionButtons) actionButtons.hidden = false;
          toggleThreads(); // Close the threads panel when a thread is selected
          // Update thread name automatically if not already updated
          if (!currentThread.autoNameUpdated && currentThread.chatHistory.length >= 4) {
            updateThreadNameFromConversation();
          }
        } else {
          console.error("Thread not found.");
        }
      } else {
        console.error("Profile or threads not found.");
      }

      // Log currentThread after loading
      console.log("Current thread after loadThread:", currentThread);
    }

    // Function to create a new thread
    async function createNewThread() {
      if (!currentProfile) {
        alert("Please select a profile first.");
        return;
      }

      console.log("Creating new thread for profile:", currentProfile.assistantName);

      const confirmCreate = confirm("You are about to create a new thread. Click OK to proceed.");
      if (!confirmCreate) {
        return;
      }

      const threadId = generateUniqueId();
      const threadName = "New Thread";
      const thread = {
        id: threadId,
        name: threadName,
        chatHistory: [],
        autoNameUpdated: false,
      };
      if (!currentProfile.threads) {
        currentProfile.threads = [];
      }
      currentProfile.threads.push(thread);
      updateProfilesInStorage();
      loadAllThreads(); // Refresh the threads list
      loadThread(currentProfile.id, threadId); // Load the new thread after creation

      // Ensure currentThread is set after loading the thread
      if (currentThread) {
        console.log("Current thread set to:", currentThread.name);
      } else {
        console.error("currentThread is not set after loading the new thread.");
      }

      // Call updateThreadNameFromConversation after loading the new thread
      if (currentThread && currentThread.chatHistory.length >= 4) {
        updateThreadNameFromConversation();
      }
    }

    // Function to update thread name from conversation history
    async function updateThreadNameFromConversation() {
      if (!currentThread || !currentThread.chatHistory || currentThread.chatHistory.length < 4 || currentThread.autoNameUpdated) return;

      const chatHistory = currentThread.chatHistory.map((msg) => `${msg.role}: ${msg.content}`).join("\n");
      const suggestedName = await getSuggestedThreadName(chatHistory);

      // Update the thread name
      currentThread.name = suggestedName;
      currentThread.autoNameUpdated = true; // Set the flag to true
      updateProfilesInStorage();
      loadAllThreads(); // Refresh the threads list
      console.log(`Updated thread name for profile ${currentProfile.assistantName}: ${suggestedName}`);
    }

    // Fungsi untuk toggle tampilan thread
    function toggleThreads() {
      const threads = document.querySelector(".urChatThreads");
      if (threads) {
        const isOpen = threads.classList.toggle("open");
        if (isOpen) {
          loadAllThreads(); // Memanggil fungsi untuk memuat semua thread jika terbuka
        }
      }
    }

    // Function to load all threads
    function loadAllThreads() {
      const threadsList = document.querySelector(".urChatThreads-list ul");
      threadsList.innerHTML = "";

      const profiles = JSON.parse(localStorage.profiles || "[]");

      profiles.forEach((profile) => {
        if (profile.threads) {
          profile.threads.forEach((thread) => {
            const listItem = document.createElement("li");
            const assistantImg = document.createElement("img");
            assistantImg.src = profile.assistantPhoto;
            assistantImg.alt = `${profile.assistantName} profile picture`;
            listItem.appendChild(assistantImg);
            const textContent = document.createElement("div");
            textContent.textContent = `${thread.name}`;
            listItem.appendChild(textContent);
            const btnGroup = document.createElement("div");
            btnGroup.className = "urChatBtn-group";
            const deleteBtn = document.createElement("button");
            deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
            deleteBtn.onclick = () => deleteThread(profile.id, thread.id);
            btnGroup.appendChild(deleteBtn);
            const renameBtn = document.createElement("button");
            renameBtn.innerHTML = '<i class="fas fa-edit"></i>';
            renameBtn.onclick = () => renameThread(profile.id, thread.id);
            btnGroup.appendChild(renameBtn);
            listItem.appendChild(btnGroup);
            listItem.onclick = () => loadThread(profile.id, thread.id);
            threadsList.appendChild(listItem);
          });
        }
      });
    }

    // Function to delete a thread
    function deleteThread(profileId, threadId) {
      if (confirm("Are you sure you want to delete this thread?")) {
        const profiles = JSON.parse(localStorage.profiles || "[]");
        const profileIndex = profiles.findIndex((profile) => profile.id === profileId);
        if (profileIndex !== -1) {
          const profile = profiles[profileIndex];
          profile.threads = profile.threads.filter((thread) => thread.id !== threadId);
          localStorage.profiles = JSON.stringify(profiles);
          loadAllThreads(); // Refresh the threads list
        }
      }
    }

    // Function to rename a thread
    function renameThread(profileId, threadId) {
      const profiles = JSON.parse(localStorage.profiles || "[]");
      const profile = profiles.find((profile) => profile.id === profileId);
      if (profile) {
        const thread = profile.threads.find((thread) => thread.id === threadId);
        if (thread) {
          const newName = prompt("Enter new thread name:", thread.name);
          if (newName) {
            thread.name = newName;
            localStorage.profiles = JSON.stringify(profiles);
            loadAllThreads(); // Refresh the threads list
          }
        }
      }
    }

    // Function to implement a function to generate a better thread name using the API
    async function getSuggestedThreadName(chatHistory) {
      const urThreadPrompt = `Generate a concise and relevant name for the following conversation. Strictly use a maximum of 5 words WITHOUT special symbols or markdown; quotation marks are allowed.\n${chatHistory}\n\nResponse Format: [Thread Name]`;
      const messages = [
        {
          role: "system",
          content: urThreadPrompt,
        },
      ];
      const seed = Math.floor(Math.random() * 10000);

      try {
        const response = await axios.post(
          API_URL,
          {
            model: "mistral-large",
            messages,
            seed,
          },
          {
            headers: {
              "Content-Type": "application/json",
            },
          }
        );

        const suggestedName = response.data.choices[0]?.message?.content || "No response generated.";
        return suggestedName.trim();
      } catch (error) {
        console.error("Error in generating thread name:", error);
        return "Error generating name";
      }
    }

    function searchThreads(searchTerm) {
      const threadItems = document.querySelectorAll(".urChatThreads-list ul li");
      searchTerm = searchTerm.toLowerCase();
      threadItems.forEach((item) => {
        const threadName = item.textContent.toLowerCase();
        if (threadName.includes(searchTerm)) {
          item.style.display = "block";
        } else {
          item.style.display = "none";
        }
      });
    }
  </script>
  <body>
    <div
      id="urChatloadingScreenEl"
      style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: #f5f5f5; display: flex; align-items: center; justify-content: center; font-family: 'Courier Prime', monospace; color: #333; z-index: 9999;"
    >
      <div style="width: 60%; text-align: left; position: relative;">
        <div id="urChatloadingTextEl" style="font-size: 0.8em; position: absolute; top: -20px; left: 0; margin-bottom: 10px;">Loading</div>
        <div style="height: 22px; width: 100%; border: 2.5px solid #333; background-color: transparent; box-sizing: border-box; display: flex; align-items: center; justify-content: center; padding: 3px;">
          <div style="height: 100%; width: 100%; background-color: transparent; display: flex; align-items: center; padding: 1px; box-sizing: border-box;">
            <div id="urChatprogressBarEl" style="height: 100%; width: 0; background-color: #333; transition: width 0.3s;"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="urChatMenu-icon" onclick="toggleMenu()">
      <i class="fas fa-bars"> </i>
    </div>
    <div class="urChatThreads-icon" onclick="toggleThreads()">
      <i class="fas fa-comments"></i>
    </div>
    <div class="urChatMenu">
      <div class="urChatClose-button" onclick="toggleMenu()">
        <i class="fas fa-times"> </i>
      </div>
      <h2>Characters Manager</h2>
      <button onclick="toggleCharacterCreation()">New Character</button>
      <div id="characterCreationCtn" hidden>
        <h3>New Character</h3>
        <label for="name"> Name: </label>
        <input id="nameEl" type="text" />
        <label for="tagline"> Tagline: </label>
        <!-- New Tagline Input -->
        <input id="taglineEl" type="text" />
        <label for="model_list_uniqueEl"> Model: </label>
        <select id="model_list_uniqueEl" onchange="saveLastSelectedModel()">
          <option value="openaai">OpenAI GPT-4o</option>
          <option value="mistral">Mistral Nemo (Unrestricted)</option>
          <option value="mistral-large">Mistral Large (Unrestricted)</option>
          <option value="llama">Llama 3.1</option>
          <option value="command-r">Command-R</option>
          <option value="unity">Unity with Mistral Large</option>
          <option value="midijourney">Midjourney Musical Transformer</option>
          <option value="rtist">Rtist Image Generator</option>
          <option value="searchgpt">SearchGPT</option>
          <option value="evil">Evil Mode - Experimental</option>
          <option value="qwen-coder">Qwen Coder 32b</option>
          <option value="p1">Pollinations 1 (OptiLLM)</option>
        </select>
        <label for="description"> Description: </label>
        <textarea id="descriptionEl"> </textarea>
        <label for="photo"> Upload Photo: </label>
        <input id="photoEl" type="file" />
        <h3>User Profile</h3>
        <label for="user_name"> Name: </label>
        <input id="user_nameEl" type="text" />
        <label for="user_description"> Description: </label>
        <textarea id="user_descriptionEl"> </textarea>
        <label for="user_photo"> Upload Photo: </label>
        <input id="user_photoEl" type="file" />
        <h3>System Profile</h3>
        <label for="system_name"> Name: </label>
        <input id="system_nameEl" type="text" />
        <label for="system_description"> Description: </label>
        <textarea id="system_descriptionEl" placeholder="You can fill the system prompt with: Strict rules for the AI, Reminder messages, Guidelines for the AI on how to interact, And more"></textarea>
        <label for="system_photo"> Upload Photo: </label>
        <input id="system_photoEl" type="file" />
        <button onclick="saveCharacter()">Save Character</button>
      </div>
      <div class="urProfiles-search-container">
        <input type="text" placeholder="Search profiles..." id="urProfiles-search-box" oninput="searchProfiles(this.value)" />
      </div>
      <div class="urChatProfile-list">
        <h3>Created Profiles</h3>
        <ul></ul>
      </div>
    </div>
    <div class="urChatThreads-icon" onclick="toggleThreads()">
      <i class="fas fa-comments"></i>
    </div>
    <div class="urChatThreads">
      <div class="urChatThreadsClose-button" onclick="toggleThreads()">
        <i class="fas fa-times"></i>
      </div>
      <h2>Threads</h2>
      <div class="urChatThreads-search-container">
        <input type="text" placeholder="Search threads..." id="urChatThreads-search-box" oninput="searchThreads(this.value)" />
      </div>
      <div class="urChatThreads-list">
        <ul></ul>
      </div>
    </div>
    <div class="urChatContainer">
      <!-- Messages dynamically show here -->
      <div id="currentThreadName"></div>
      <div class="urChatHomepage-prompt">
        [urHomepage]
        <div class="urChat-tabs">
          <div class="urChat-tab-header">
            <div onclick="toggleTab(1)" id="tab-1-header">
              <i class="fas fa-comments"></i>
            </div>
            <div onclick="toggleTab(2)" id="tab-2-header">
              <i class="fas fa-info-circle"></i>
            </div>
            <div onclick="toggleTab(3)" id="tab-3-header">
              <i class="fas fa-chart-bar"></i>
            </div>
            <div onclick="toggleTab(4)" id="tab-4-header">
              <i class="fas fa-user"></i>
            </div>
          </div>
          <div class="urChat-tab-content" id="content-1">
            <div class="content">[urComments]</div>
          </div>
          <div class="urChat-tab-content" id="content-2">
            <div class="content">[urAbout]</div>
          </div>
          <div class="urChat-tab-content" id="content-3">
            <div class="content">[urStats]</div>
          </div>
          <div class="urChat-tab-content" id="content-4">
            <div class="content">
              <hr />
              <h1>Profile Creation</h1>
              <hr />
              [output]<br />
              <br />
              <textarea class="urProfileInputArea" id="urProfileImgInputEl" placeholder="Write your profile description here..."></textarea>
              <button class="urProfileSendButton" onclick="update()">
                <i class="fas fa-paper-plane"></i>
              </button>
              <hr />
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="urChatTyping-indicator" hidden>
      <span></span>
      <span></span>
      <span></span>
    </div>
    <div class="scroll-to-bottom-btn hidden" onclick="scrollToBottom()">
      <i class="fas fa-arrow-down"></i>
    </div>
    <div class="urChatInput-container">
      <textarea placeholder="Type your reply here..."></textarea>
      <div class="urChatButton-container">
        <button class="urChatSend-button" onclick="sendUserMessage()"><i class="fas fa-paper-plane"></i></button>
        <button class="urChatPersonate-button" onclick="personateMe()"><i class="fas fa-magic"></i></button>
        <button class="urChatImageBtn" onclick="generateImageDescription()"><i class="fas fa-image"></i></button>
        <button class="urChatFullTextarea-Button" onclick="toggleFullTextarea()"><i class="fas fa-expand"></i></button>
      </div>
    </div>
    <div class="urChatToken-use">Token use (0/3000)</div>
    [something("urchat-ai","https://user-uploads.perchance.org/file/603c73acdf70dbf39a85275373cacd1f.png")]
    <!-- Added buttons for Clear Chat, Save Chat, and Load Chat -->
    <div class="action-buttons" hidden>
      <button onclick="clearChat()"><i class="fas fa-trash"></i> Clear Chat</button>
      <button onclick="saveChat(1)"><i class="fas fa-user"></i> Save Character</button>
      <button onclick="saveChat(2)"><i class="fas fa-save"></i> <i class="fas fa-plus"></i> <i class="fas fa-comments"></i> Save All</button>
      <input type="file" id="loadChatInput" style="display: none;" onchange="loadChatJson(this)" />
      <button onclick="loadChatInput.click()"><i class="fas fa-upload"></i> Load Chat</button>
    </div>
  </body>
</html>
